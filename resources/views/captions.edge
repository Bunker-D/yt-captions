<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Get Youtube Captions</title>
	<link href="https://fonts.googleapis.com/css?family=Poppins:400,500&display=swap" rel="stylesheet">
	@include('partials/common-style')
	<style>
		#menu {
			position: fixed;
			z-index: 90;
			top: 16px;
			left: 11px;
			max-height: 270px;
			transition: max-height .15s;
			overflow: hidden;
		}
		#menu.menu-off { max-height: 53px; }
		.menu-item {
			cursor: pointer;
			line-height: 0;
			display: table;
		}
		.menu-item img {
			width: 35px;
			height: 35px;
			margin: 9px;
			background-color: white;
		}
		.menu-text {
			display: table-cell;
			vertical-align: middle;
			margin: 0 9px;
			max-width: 0;
			transition: max-width .2s;
			overflow: hidden;
			background-color: white;
		}
		.menu-item:hover .menu-text { max-width: 12em; }

		main {
			max-width: 850px;
			width: 80%;
			margin: auto;
		}

		.head {
			width: 100%;
			display: flex;
			padding: 2em 0 ;
		}
		img {
			width: 20%;
			max-width: 4.5em;
			margin: .4em 1em 0 0;
			height: fit-content;
		}
		.video-descriptor {
			flex-grow: 100
		}

		blockquote { margin: 2em 0; }
		blockquote:focus { outline: none; }

		.foot {
			display: block;
			width: 100%;
			height: 4em;
    		border-top: 2px solid #dc0000;
		}

		span[data-time]{
			position: relative;
		}
		span[data-time]:hover::before {
			content: '';
			position: absolute;
			bottom: calc( 100% + 4px );
			background-color: #dc0000;
			width: 0.7em;
			height: 0.8em;
			-webkit-transform: skew(0, 125deg);
			-moz-transform: skew(0, 125deg);
			transform: skew(0, 125deg);
		}
		span[data-time]:hover::after {
			content: attr(data-time);
			font-weight: bold;
			position: absolute;
			bottom: calc( 100% + 4px );
			left: 0;
			background-color: #dc0000;
			color: white;
			font-size: .9em;
			line-height: 1em;
			padding: 5px 7px;
			border-radius: 4px;
			display: inline-block;
			white-space: nowrap;
		}
		p > span[data-time]:first-child::after,
		p > :first-child > span[data-time]:first-child::after,
		p > :first-child > :first-child > span[data-time]:first-child::after,
		p > :first-child > :first-child > :first-child > span[data-time]:first-child::after {
			content: attr(data-time);
			font-weight: normal;
			position: absolute;
			bottom: unset;
			left: unset;
			right: 100%;
			top: 3px;
			background-color: #dc0000;
			color: white;
			font-size: .8em;
			line-height: unset;
			padding: 0 0.4em;
			border-radius: 6px;
			margin-right: 0.9em;
		}
		p > span[data-time]:first-child:hover::before,
		p > :first-child > span[data-time]:first-child:hover::before,
		p > :first-child > :first-child > span[data-time]:first-child:hover::before,
		p > :first-child > :first-child > :first-child > span[data-time]:first-child:hover::before {
			content: '';
			position: absolute;
			bottom: 8px;
			right: calc(100% + 0.6em);
			background-color: #dc0000;
			width: 0.7em;
			height: 0.41em;
			-webkit-transform: skew(60deg, -30deg);
			-moz-transform: skew(60deg, -30deg);
			transform: skew(60deg, -30deg);
		}

		#ms-img-no { display: none; }
		.ms-accuracy #ms-img-no { display: block; }
		.ms-accuracy #ms-img-yes { display: none; }
		.ms-accuracy span[data-time]:hover::after,
		.ms-accuracy p > span[data-time]:first-child::after,
		.ms-accuracy p > :first-child > span[data-time]:first-child::after,
		.ms-accuracy p > :first-child > :first-child > span[data-time]:first-child::after,
		.ms-accuracy p > :first-child > :first-child > :first-child > span[data-time]:first-child::after {
			content: attr(data-time-ms);
		}

		#time-editor {
			font-family: monospace;
			font-size: 35px;
			background-color: #dc0000;
			width: fit-content;
			color: #fff;
			line-height: 1em;
			padding: 8px 21px;
			border-radius: 24px;
			border: solid 8px white;
			position: absolute;
			left: 32%;
			top: 21%;
			outline: none;
		}
		#time-editor:focus .active {
			background: #111;
		}
		.time-edition-target { color: #dc0000; }
	</style>
</head>
<body>

<main>

	<div class="head">
		<img src="/yt-captions.png">
		@!videoDescriptor( { id, title, channel, date, url } )
	</div>

	<blockquote id="captions" contenteditable="true">
		@each( par in text )~
<p>
			@each( bit in par )~
<span
	data-time="{{ bit[ 0 ].split( '.' )[ 0 ] }}"
	data-time-ms="{{ bit[ 0 ] }}"
>{{{ bit[ 1 ] }}}</span>
			@endeach~
</p>
		@endeach~
	</blockquote>
	<div class="foot"></div>
</main>

<div id="menu" class="menu-off">
	<div class="menu-item" id="burger">
		<img src="/icons/burger.png">
	</div>
	<div class="menu-item" onclick="msAccuracy()">
		<img src="/icons/ms-yes.png" id="ms-img-yes"><img src="/icons/ms-no.png" id="ms-img-no">
		<div class="menu-text">Switch&nbsp;time&nbsp;accuracy&nbsp;&nbsp;</div>
	</div>
	<div class="menu-item" onclick="mergeWith()">
		<img src="/icons/Script.png">
		<div class="menu-text">Merge&nbsp;with&nbsp;script&nbsp;&nbsp;</div>
	</div>
	<div class="menu-item" onclick="saveCaptions()">
		<img src="/icons/download.png">
		<div class="menu-text">Save&nbsp;current&nbsp;state&nbsp;&nbsp;</div>
	</div>
	<div class="menu-item" onclick="exportCaptions()">
		<img src="/icons/Export.png">
		<div class="menu-text">Export&nbsp;subtitles&nbsp;&nbsp;</div>
	</div>
	{{-- //IMPROVE italic, bold, underlined, font color --}}
</div>

<script>
	const menu = document.getElementById( 'menu' );
	const captions = document.getElementById( 'captions' );

	document.getElementById( 'burger' ).onclick = () => menu.classList.toggle( 'menu-off' );
	function msAccuracy() {
		document.body.classList.toggle( 'ms-accuracy' );
	}
	function mergeWith() {
		/*TODO function: merge with script
			[ ] Upload (such as in home page)
			[ ] POST to let the controller do the merging
			[ ] Update the #captions element
		*/
	}
	function saveCaptions() {
		fileFromServer( '/convert/save', '.cpt' );
	}
	function exportCaptions() {
		fileFromServer( '/convert/srt', '.srt' );
	}
	function fileFromServer( requestURL, fileExtension ) {
		let xmlHttp = new XMLHttpRequest();
		xmlHttp.onreadystatechange = function() { 
			if ( xmlHttp.readyState == 4 && xmlHttp.status == 200 ) {
				const filename = document.getElementById( 'video-title' ).textContent.replace( /[.\\/:*?"<>|]/g, '' ) + fileExtension;
				const element = document.createElement( 'a' );
				element.setAttribute( 'href', 'data:text/plain;charset=utf-8,' + encodeURIComponent( xmlHttp.responseText ) );
				element.setAttribute( 'download', filename );
				element.style.display = 'none';
				document.body.appendChild(element);
				element.click();
				document.body.removeChild(element);
			}
		}
		xmlHttp.open( 'POST', requestURL, true );
		xmlHttp.setRequestHeader( "Content-Type", "application/json" );
		const args = { captions: captionsTable() };
		for ( const key of [ 'title', 'author', 'date' ] ) {
			let value = document.getElementById( 'video-' + key );
			if ( value ) {
				value = value.textContent.trim();
				if ( value.endsWith( ',' ) ) value = value.substr( 0, value.length - 1 ).trim();
				if ( value ) args[ key ] = value;
			}
		}
		let url = document.getElementById( 'video-descriptor' );
		if ( url ) {
			url = url.getAttribute( 'href' );
			if ( url ) args.url = url;
		}
		xmlHttp.send( JSON.stringify( args ) );
	}

	/**
	 * Convert the current captions state into an array of paragraphs,
	 * that are described as an array of timed bits, being described as [time,text].
	 */
	function captionsTable()/*: [string,string][][]*/ {
		cleanEditor();
		const res = [ [ [ '', '' ] ] ];
		let currentPar = res[ 0 ];
		let currentBit = currentPar[ 0 ];
		const newPar = () => {
			if ( currentPar.length ) {
				currentPar = [];
				res.push( currentPar );
			}
		};
		const newBit = ( span ) => {
			if ( ! span.textContent ) return;
			let t;
			try {
				t = span.getAttribute( 'data-time-ms' );
			} catch ( e ) { // Text node
				currentBit[ 1 ] += span.textContent.replaceAll( '&', '&amp;' ).replaceAll( '<', '&lt;' );
			}
			if ( t ) { // Timed span
				currentBit = [ t, span.innerHTML ];
				currentPar.push( currentBit );
			} else { // HTML tag, but not a timed span
				const tag = [ '', 'i', 'b', 'u' ][ [ 'I', 'B', 'U' ].indexOf( span.tagName ) + 1 ];
				const start = currentPar.length;
				for ( const subspan of span.childNodes ) {
					newBit( subspan );
				}
				if ( tag && currentPar.length > start ) {
					currentPar[ start ][ 1 ] = '<' + tag + '>' + currentPar[ start ][ 1 ];
					currentBit[ 1 ] += '</' + tag + '>';
				}
			}
		};
		for ( const p of captions.childNodes ) {
			if ( p.tagName === 'P' ) {
				newPar();
				for ( const span of p.childNodes ) {
					newBit( span );
				}
			} else {
				if ( p.textContent.trim() ) newBit( p );
			}
		}
		if ( ! currentPar.length ) res.pop();
		if ( res[ 0 ][ 0 ][ 1 ].trim() ) {
			res[ 0 ][ 0 ][ 0 ] = ( res.length > 1 ) ? res[ 1 ][ 0 ][ 0 ].replace( /\d/g, '0' ) : '00:00:00.000';
		} else {
			res.splice( 0 , 1 );
		}
		return res;
	}
	/**
	 * Remove empty spans, remove unnecessary nbsp's, remove unsupported HTML tags, put French-typography-related nbsp's
	 */
	function cleanEditor() {
		const nbsp = String.fromCharCode( 160 );
		const clean = ( el ) => {
			if ( el.nodeType === 1 ) {
				if ( ! el.textContent.trim() ) {
					if ( el.tagName !== 'BR' ) el.remove();
					return;
				}
				for ( const e of el.childNodes ) clean( e );
			} else if ( el.nodeType === 3 ) {
				let s = el.textContent;
				if ( s[ 0 ] === nbsp ) s = ' ' + s.substr( 1 );
				if ( s[ s.length - 1 ] === nbsp ) s = s.substr( 0, s.length - 1 ) + ' ';
				el.textContent = s.replace( /(?<=[«({\[]) | (?=[»)}\]:;!?])/g, nbsp );
			}
		}
		for ( const el of captions.childNodes ) clean( el );
	}

	document.addEventListener( 'copy', function( e ) {
		// Abort if invalid selection (i.e. not contained within the captions block)
		const sel = window.getSelection();
		if ( sel.rangeCount !== 1 ) return;
		const range = sel.getRangeAt( 0 );
		if ( ! ( captions.contains( range.startContainer ) && captions.contains( range.startContainer ) ) ) return;
		// Copy the selection into a div to work on it
		const clip = document.createElement( 'div' );
		clip.append( range.cloneContents() )
		// Add timings where needed
		let noTime = true;
		const timeTag = ( document.body.classList.contains( 'ms-accuracy' ) ) ? 'data-time-ms' : 'data-time';
		const time = ( el ) => {
			let t;
			for ( const subel of el.children ) {
				t = subel.getAttribute( timeTag );
				if ( t ) break;
			}
			if ( t ) {
				noTime = false;
				el.innerHTML = '<code>' + t + ' - </code>' + el.innerHTML;
			}
		};
		for ( const el of clip.children ) if ( el.tagName === 'P' ) time( el );
		if ( noTime ) time( clip );
		if ( noTime ) {
			let el = sel.anchorNode;
			let t;
			do {
				el = el.parentElement;
				t = el.getAttribute( timeTag );
			} while ( ! t )
			if ( t ) clip.innerHTML = '<code>' + t + ' - </code>' + clip.innerHTML;
		}
		// Update the clipboard
		e.clipboardData.setData( 'text/html', clip.innerHTML );
		clip.remove();
		e.preventDefault();
	} );
	
	document.addEventListener( 'paste', function( e ) {
		// Abort if invalid selection (i.e. not contained within the captions block)
		const sel = window.getSelection();
		if ( sel.rangeCount !== 1 ) return;
		const range = sel.getRangeAt( 0 );
		if ( ! ( captions.contains( range.startContainer ) && captions.contains( range.startContainer ) ) ) return;
		e.preventDefault();
		// Get the data to paste into a div to work on it
		const clip = document.createElement( 'div' );
		clip.innerHTML = e.clipboardData.getData( "text/html" );
		// Inject the cleaned HTML into another div
		let toPaste = document.createElement( 'div' );
		let textNode;
		const transfer = ( fromEl, toEl ) => {
			const text = ( t ) => {
				if ( textNode ) {
					textNode.appendData( t );
				} else {
					textNode = document.createTextNode( t );
					toEl.appendChild( textNode );
				}
			}
			for ( const el of fromEl.childNodes ) {
				if ( el.nodeType === 1 ) {
					const tag = { I: 'i', EM: 'i', B: 'b', STRONG: 'b',  U: 'u' }[ el.tagName ]; // # <font>
					if ( tag ) {
						textNode = undefined;
						const newEl = document.createElement( tag );
						toEl.appendChild( newEl );
						transfer( el, newEl );
						textNode = undefined;
					} else if ( el.tagName === 'P' ) {
						text( ' ' );
						transfer( el, toEl );
						text( ' ' );
					} else if ( el.tagName === 'BR' ) {
						text( ' ' );
					} else if ( el.tagName !== 'CODE' || ! el.innerHTML.match( /^[\d:.]+ - $/ ) )  {
						transfer( el, toEl );
					}
				} else if ( el.nodeType === 3 ) {
					text( el.textContent );
				}
			}
		};
		transfer( clip, toPaste );
		// Paste
		sel.deleteFromDocument();
		console.log( toPaste.innerHTML );
		toPaste = toPaste.childNodes;
		console.log( toPaste.length );
		for ( let k = toPaste.length; k--; ) {
			range.insertNode( toPaste[ k ] );
		}
		//IMPROVE Pasting: move writing head to after the pasted text + be able to Ctrl+Z
	} );

	captions.addEventListener( 'click', ( e ) => {
		/*TODO Timed span merging
			When the new time is lower than the following ones, the latter should be removed (span merging).
			When the new time is higher than the following ones, the latter should be removed (span merging).
			While the time is editing, text coloring should reflect that: all affected spans should be color.
		*/
		// Only Alt+Click must be handled
		if ( ! e.ctrlKey ) return;
		e.preventDefault();
		//TODO Ctrl+Alt+Click should also cut the span at the word, for creating new timing locations
		// Get the clicked timed element
		let el = e.target;
		while ( ! el.getAttribute( 'data-time-ms' ) ) {
			if ( el === captions ) return;
			el = el.parentElement;
		}
		for ( const span of captions.getElementsByClassName( 'time-edition-target' ) ) span.classList.remove( 'time-edition-target' );
		el.classList.add( 'time-edition-target' );
		// Create a time editor
		const timeEl = document.createElement( 'button' );
		timeEl.id = 'time-editor';
		let ms = false;
		for ( const char of el.getAttribute( 'data-time-ms' ) ) {
			if ( char.charCodeAt( 0 ) < 48 || char.charCodeAt( 0 ) > 57 ) {
				timeEl.appendChild( document.createTextNode( char ) );
				if ( char === '.' ) ms = true;
			} else {
				const d = document.createElement( 'span' );
				d.innerHTML = char;
				if ( ms ) d.classList.add( 'ms' );
				timeEl.appendChild( d );
			}
		}
		// Set digit maximal values
		let k = timeEl.children.length - ( ( ms ) ? 5 : 2);
		if ( k >= 0 ) {
			timeEl.children[ k ].dataset.max = '5';
			k -= 2;
			if ( k >= 0 ) timeEl.children[ k ].dataset.max = '5';
		}
		timeEl.children[ 0 ].classList.add( 'active' );
		// Event listeners
		timeEl.addEventListener( 'click', ( evt ) => {
			evt.preventDefault();
			const target = evt.target;
			if ( target.tagName === 'SPAN' && ! target.classList.contains( 'active' ) ) {
				for ( const digit of target.parentElement.children ) digit.classList.remove( 'active' );
				target.classList.add( 'active' );
			}
		} );
		timeEl.addEventListener( 'keydown', ( evt ) => {
			evt.preventDefault();
			const key = evt.key;
			if ( '0123456789'.indexOf( key ) >= 0 ) {
				const digit = document.getElementById( 'time-editor' ).getElementsByClassName( 'active' )[ 0 ];
				if ( digit.dataset.max && '012345'.indexOf( key ) < 0 ) return;
				digit.innerHTML = key;
				const next = digit.nextElementSibling;
				if ( next ) {
					digit.classList.remove( 'active' );
					next.classList.add( 'active' );
				}
			} else if ( key === 'Escape' || key === 'Enter' ) {
				const timeEl = document.getElementById( 'time-editor' );
				for ( const el of captions.getElementsByClassName( 'time-edition-target' ) ) {
					if ( key === 'Enter' ) {
						el.setAttribute( 'data-time-ms', timeEl.textContent );
						el.setAttribute( 'data-time', timeEl.textContent.split( '.' )[ 0 ] );
					}
					el.classList.remove( 'time-edition-target' );
				}
				timeEl.remove();
			} else if ( key.startsWith( 'Arrow' ) ) {
				const digit = document.getElementById( 'time-editor' ).getElementsByClassName( 'active' )[ 0 ];
				if ( key === 'ArrowLeft' || key === 'ArrowRight' ) {
					const next = ( key === 'ArrowRight' ) ? digit.nextElementSibling : digit.previousElementSibling;
					if ( next ) {
						digit.classList.remove( 'active' );
						next.classList.add( 'active' );
					}
				} else if ( key === 'ArrowUp' ) {
					const recursive = ( d ) => {
						if ( ! d ) return false;
						const n = d.innerHTML;
						if ( n === ( d.dataset.max ?? '9' ) ) {
							if ( recursive( d.previousElementSibling ) ) {
								d.innerHTML = '0';
								return true;
							}
							return false
						}
						d.innerHTML = Number( n ) + 1;
						return true;
					}
					recursive( digit );
				} else if ( key === 'ArrowDown' ) {
					const recursive = ( d ) => {
						if ( ! d ) return false;
						const n = d.innerHTML;
						if ( n === '0' ) {
							if ( recursive( d.previousElementSibling ) ) {
								d.innerHTML = d.dataset.max ?? '9';
								return true;
							}
							return false
						}
						d.innerHTML = Number( n ) - 1;
						return true;
					}
					recursive( digit );
				}
			}
		} );
		document.body.getElementsByTagName( 'main' )[ 0 ].appendChild( timeEl );
		timeEl.focus();
	} );
	/*TODO Be able to add timings
		Maybe middle click, or a click on the time tag, could create an editable time tag element that is closed (deleted) when losing focus, then the data is stored.
	*/
</script>

</body>
</html>

