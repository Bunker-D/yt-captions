<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Get Youtube Captions</title>
	<link href="https://fonts.googleapis.com/css?family=Poppins:400,500&display=swap" rel="stylesheet">
	@include('partials/common-style')
	<style>
		#menu {
			position: fixed;
			z-index: 90;
			top: 16px;
			left: 11px;
			max-height: 270px;
			transition: max-height .15s;
			overflow: hidden;
		}
		#menu.menu-off { max-height: 53px; }
		.menu-item {
			cursor: pointer;
			line-height: 0;
			display: table;
		}
		.menu-item img {
			width: 35px;
			height: 35px;
			margin: 9px;
			background-color: white;
		}
		.menu-text {
			display: table-cell;
			vertical-align: middle;
			margin: 0 9px;
			max-width: 0;
			transition: max-width .2s;
			overflow: hidden;
			background-color: white;
		}
		.menu-item:hover .menu-text { max-width: 12em; }

		main {
			max-width: 850px;
			width: 80%;
			margin: auto;
		}

		.head {
			width: 100%;
			display: flex;
			padding: 2em 0 ;
		}
		img {
			width: 20%;
			max-width: 4.5em;
			margin: .4em 1em 0 0;
			height: fit-content;
		}
		.video-descriptor {
			flex-grow: 100
		}

		blockquote { margin: 2em 0; }
		blockquote:focus { outline: none; }

		.foot {
			display: block;
			width: 100%;
			height: 4em;
    		border-top: 2px solid #dc0000;
		}

		span[data-time]{
			position: relative;
		}
		span[data-time]:not(:first-child):hover::before {
			content: '';
			position: absolute;
			bottom: calc( 100% + 4px );
			background-color: #dc0000;
			width: 0.7em;
			height: 0.8em;
			-webkit-transform: skew(0, 125deg);
			-moz-transform: skew(0, 125deg);
			transform: skew(0, 125deg);
		}
		span[data-time]:not(:first-child):hover::after {
			content: attr(data-time);
			position: absolute;
			bottom: calc( 100% + 4px );
			left: 0;
			background-color: #dc0000;
			color: white;
			font-weight: bold;
			line-height: 1em;
			padding: 5px 7px;
			border-radius: 4px;
			display: inline-block;
			white-space: nowrap;
			font-size: .9em;
		}
		span[data-time]:first-child::after {
			content: attr(data-time);
			background-color: #dc0000;
			color: white;
			font-size: .8em;
			padding: 0 0.4em;
			margin-right: 0.9em;
			border-radius: 6px;
			position: absolute;
			right: 100%;
			top: 3px;
		}
		span[data-time]:first-child:hover::before {
			content: '';
			position: absolute;
			bottom: 8px;
			right: calc(100% + 0.6em);
			background-color: #dc0000;
			width: 0.7em;
			height: 0.41em;
			-webkit-transform: skew(60deg, -30deg);
			-moz-transform: skew(60deg, -30deg);
			transform: skew(60deg, -30deg);
		}
	</style>
	{{-- //BUG using "span[data-time]:first-child" is problematic when spans end up within a formatting tag (e.g. <b>â€¦</b>) --}}
</head>
<body>

<main>

	<div class="head">
		<img src="/yt-captions.png">
		@!videoDescriptor( { id: id, title: title, channel: channel, date: date } )
	</div>

	<blockquote id="captions" contenteditable="true">
		<p>
			@each( bit in text )~
<span
	data-time="{{ bit[ 0 ].split( '.' )[ 0 ] }}"
	data-time-ms="{{ bit[ 0 ] }}"
>{{ bit[ 1 ] }}</span>
			@endeach~
		</p>
	</blockquote>
	<div class="foot"></div>
</main>

<div id="menu" class="menu-off">
	<div class="menu-item" id="burger">
		<img src="/icons/burger.png">
	</div>
	<div class="menu-item" onclick="msAccuracy()">
		<img src="/icons/ms-yes.png" id="ms-img">
		<div class="menu-text">Switch&nbsp;time&nbsp;accuracy&nbsp;&nbsp;</div>
	</div>
	<div class="menu-item" onclick="mergeWith()">
		<img src="/icons/Script.png">
		<div class="menu-text">Merge&nbsp;with&nbsp;script&nbsp;&nbsp;</div>
	</div>
	<div class="menu-item" onclick="saveCaptions()">
		<img src="/icons/download.png">
		<div class="menu-text">Save&nbsp;current&nbsp;state&nbsp;&nbsp;</div>
	</div>
	<div class="menu-item" onclick="exportCaptions()">
		<img src="/icons/Export.png">
		<div class="menu-text">Export&nbsp;subtitles&nbsp;&nbsp;</div>
	</div>
	{{-- //IMPROVE italic, bold, underlined, font color --}}
</div>

<script>
	const menu = document.getElementById( 'menu' );
	const captions = document.getElementById( 'captions' );
	document.getElementById( 'burger' ).onclick = () => menu.classList.toggle( 'menu-off' );
	function msAccuracy() {
		const img = document.getElementById( 'ms-img' );
		img.setAttribute( 'src',
			( img.getAttribute( 'src' ) === '/icons/ms-no.png' )
				? '/icons/ms-yes.png'
				: '/icons/ms-no.png'
		);
		/*TODO function: ms accuracy */
	}
	function mergeWith() {
		/*TODO function: merge with script */
	}
	function saveCaptions() {
		fileFromServer( '/convert/save', '.cpt' );
	}
	function exportCaptions() {
		fileFromServer( '/convert/srt', '.srt' );
	}
	function fileFromServer( requestURL, fileExtension ) {
		let xmlHttp = new XMLHttpRequest();
		xmlHttp.onreadystatechange = function() { 
			if ( xmlHttp.readyState == 4 && xmlHttp.status == 200 ) {
				console.log( xmlHttp.responseText ); //HACK
				const filename = document.getElementById( 'video-title' ).textContent.replace( /[.\\/:*?"<>|]/g, '' ) + fileExtension;
				const element = document.createElement( 'a' );
				element.setAttribute( 'href', 'data:text/plain;charset=utf-8,' + encodeURIComponent( xmlHttp.responseText ) );
				element.setAttribute( 'download', filename );
				element.style.display = 'none';
				document.body.appendChild(element);
				element.click();
				document.body.removeChild(element);
			}
		}
		xmlHttp.open( 'POST', requestURL, true );
		xmlHttp.setRequestHeader( "Content-Type", "application/json" );
		xmlHttp.send( JSON.stringify( { captions: captionsTable() } ) );
	}

	/**
	 * Convert the current captions state into an array of paragraphs,
	 * that are described as an array of timed bits, being described as [time,text].
	 */
	function captionsTable()/*: [string,string][][]*/ {
		cleanEditor();
		const res = [ [ [ '', '' ] ] ];
		let currentPar = res[ 0 ];
		let currentBit = currentPar[ 0 ];
		const newPar = () => {
			if ( currentPar.length ) {
				currentPar = [];
				res.push( currentPar );
			}
		};
		const newBit = ( span ) => {
			if ( ! span.textContent ) return;
			let t;
			try {
				t = span.getAttribute( 'data-time-ms' );
			} catch ( e ) { // Text node
				currentBit[ 1 ] += span.textContent.replaceAll( '&', '&amp;' ).replaceAll( '<', '&lt;' );
			}
			if ( t ) { // Timed span
				currentBit = [ t, span.innerHTML ];
				currentPar.push( currentBit );
			} else { // HTML tag, but not a timed span
				const tag = [ '', 'i', 'b', 'u' ][ [ 'I', 'B', 'U' ].indexOf( span.tagName ) + 1 ];
				const start = currentPar.length;
				for ( const subspan of span.childNodes ) {
					newBit( subspan );
				}
				if ( tag && currentPar.length > start ) {
					currentPar[ start ][ 1 ] = '<' + tag + '>' + currentPar[ start ][ 1 ];
					currentBit[ 1 ] += '</' + tag + '>';
				}
			}
		};
		for ( const p of captions.childNodes ) {
			if ( p.tagName === 'P' ) {
				newPar();
				for ( const span of p.childNodes ) {
					newBit( span );
				}
			} else {
				newBit( p );
			}
		}
		if ( ! currentPar.length ) res.pop();
		if ( res[ 0 ][ 0 ][ 1 ].trim() ) {
			res[ 0 ][ 0 ][ 0 ] = ( res.length > 1 ) ? res[ 1 ][ 0 ][ 0 ].replace( /\d/g, '0' ) : '00:00:00.000';
		} else {
			res.splice( 0 , 1 );
		}
		return res;
	}
	// Convert a captions-describing array into a captions-describing string
	function encodeCaptions( captions/*: [string,string][][]*/ )/*: string*/ {
		return (
			captions.map( ( paragraph ) =>
				paragraph.map( ( [ t, w ] ) =>
					'{' + t + '}' + w.replace( /{(\/*[\d:.]+)}/g, ( _, w ) => '{/' + w + '}' )
				).join( '' )
			).join( '{:}' )
		);
	}
	// Remove unnecessary nbsp's, remove unsupported HTML tags, put French-typography-related nbsp's
	function cleanEditor() {
		//TODO  cleanEditor()
	}
</script>

</body>
</html>
