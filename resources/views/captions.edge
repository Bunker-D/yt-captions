<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Get Youtube Captions</title>
	<link href="https://fonts.googleapis.com/css?family=Poppins:400,500&display=swap" rel="stylesheet">
	@include('partials/common-style')
	<style>
		#menu {
			position: fixed;
			z-index: 90;
			top: 16px;
			left: 11px;
			max-height: 270px;
			transition: max-height .15s;
			overflow: hidden;
		}
		#menu.menu-off { max-height: 53px; }
		.menu-item {
			cursor: pointer;
			line-height: 0;
			display: table;
		}
		.menu-item img {
			width: 35px;
			height: 35px;
			margin: 9px;
			background-color: white;
		}
		.menu-text {
			display: table-cell;
			vertical-align: middle;
			margin: 0 9px;
			max-width: 0;
			transition: max-width .2s;
			overflow: hidden;
			background-color: white;
		}
		.menu-item:hover .menu-text { max-width: 12em; }

		main {
			max-width: 850px;
			width: 80%;
			margin: auto;
		}

		.head {
			width: 100%;
			display: flex;
			padding: 2em 0 ;
		}
		img {
			width: 20%;
			max-width: 4.5em;
			margin: .4em 1em 0 0;
			height: fit-content;
		}
		.video-descriptor {
			flex-grow: 100
		}

		blockquote { margin: 2em 0; }
		blockquote:focus { outline: none; }

		.foot {
			display: block;
			width: 100%;
			height: 4em;
    		border-top: 2px solid #dc0000;
		}

		span[data-time]{
			position: relative;
		}
		span[data-time]:hover::before {
			content: '';
			position: absolute;
			bottom: calc( 100% + 4px );
			background-color: #dc0000;
			width: 0.7em;
			height: 0.8em;
			-webkit-transform: skew(0, 125deg);
			-moz-transform: skew(0, 125deg);
			transform: skew(0, 125deg);
		}
		span[data-time]:hover::after {
			content: attr(data-time);
			font-weight: bold;
			position: absolute;
			bottom: calc( 100% + 4px );
			left: 0;
			background-color: #dc0000;
			color: white;
			font-size: .9em;
			line-height: 1em;
			padding: 5px 7px;
			border-radius: 4px;
			display: inline-block;
			white-space: nowrap;
		}
		p > span[data-time]:first-child::after,
		p > :first-child > span[data-time]:first-child::after,
		p > :first-child > :first-child > span[data-time]:first-child::after,
		p > :first-child > :first-child > :first-child > span[data-time]:first-child::after {
			content: attr(data-time);
			font-weight: normal;
			position: absolute;
			bottom: unset;
			left: unset;
			right: 100%;
			top: 3px;
			background-color: #dc0000;
			color: white;
			font-size: .8em;
			line-height: unset;
			padding: 0 0.4em;
			border-radius: 6px;
			margin-right: 0.9em;
		}
		p > span[data-time]:first-child:hover::before,
		p > :first-child > span[data-time]:first-child:hover::before,
		p > :first-child > :first-child > span[data-time]:first-child:hover::before,
		p > :first-child > :first-child > :first-child > span[data-time]:first-child:hover::before {
			content: '';
			position: absolute;
			bottom: 8px;
			right: calc(100% + 0.6em);
			background-color: #dc0000;
			width: 0.7em;
			height: 0.41em;
			-webkit-transform: skew(60deg, -30deg);
			-moz-transform: skew(60deg, -30deg);
			transform: skew(60deg, -30deg);
		}

		#ms-img-no { display: none; }
		.ms-accuracy #ms-img-no { display: block; }
		.ms-accuracy #ms-img-yes { display: none; }
		.ms-accuracy span[data-time]:hover::after,
		.ms-accuracy p > span[data-time]:first-child::after,
		.ms-accuracy p > :first-child > span[data-time]:first-child::after,
		.ms-accuracy p > :first-child > :first-child > span[data-time]:first-child::after,
		.ms-accuracy p > :first-child > :first-child > :first-child > span[data-time]:first-child::after {
			content: attr(data-time-ms);
		}
	</style>
</head>
<body>

<main>

	<div class="head">
		<img src="/yt-captions.png">
		@!videoDescriptor( { id, title, channel, date, url } )
	</div>

	<blockquote id="captions" contenteditable="true">
		@each( par in text )~
<p>
			@each( bit in par )~
<span
	data-time="{{ bit[ 0 ].split( '.' )[ 0 ] }}"
	data-time-ms="{{ bit[ 0 ] }}"
>{{{ bit[ 1 ] }}}</span>
			@endeach~
</p>
		@endeach~
	</blockquote>
	<div class="foot"></div>
</main>

<div id="menu" class="menu-off">
	<div class="menu-item" id="burger">
		<img src="/icons/burger.png">
	</div>
	<div class="menu-item" onclick="msAccuracy()">
		<img src="/icons/ms-yes.png" id="ms-img-yes"><img src="/icons/ms-no.png" id="ms-img-no">
		<div class="menu-text">Switch&nbsp;time&nbsp;accuracy&nbsp;&nbsp;</div>
	</div>
	<div class="menu-item" onclick="mergeWith()">
		<img src="/icons/Script.png">
		<div class="menu-text">Merge&nbsp;with&nbsp;script&nbsp;&nbsp;</div>
	</div>
	<div class="menu-item" onclick="saveCaptions()">
		<img src="/icons/download.png">
		<div class="menu-text">Save&nbsp;current&nbsp;state&nbsp;&nbsp;</div>
	</div>
	<div class="menu-item" onclick="exportCaptions()">
		<img src="/icons/Export.png">
		<div class="menu-text">Export&nbsp;subtitles&nbsp;&nbsp;</div>
	</div>
	{{-- //IMPROVE italic, bold, underlined, font color --}}
</div>

<script>
	const menu = document.getElementById( 'menu' );
	const captions = document.getElementById( 'captions' );
	document.getElementById( 'burger' ).onclick = () => menu.classList.toggle( 'menu-off' );
	function msAccuracy() {
		document.body.classList.toggle( 'ms-accuracy' );
	}
	function mergeWith() {
		/*TODO function: merge with script
			[ ] Upload (such as in home page)
			[ ] POST to let the controller do the merging
			[ ] Update the #captions element
		*/
	}
	function saveCaptions() {
		fileFromServer( '/convert/save', '.cpt' );
	}
	function exportCaptions() {
		fileFromServer( '/convert/srt', '.srt' );
	}
	function fileFromServer( requestURL, fileExtension ) {
		let xmlHttp = new XMLHttpRequest();
		xmlHttp.onreadystatechange = function() { 
			if ( xmlHttp.readyState == 4 && xmlHttp.status == 200 ) {
				const filename = document.getElementById( 'video-title' ).textContent.replace( /[.\\/:*?"<>|]/g, '' ) + fileExtension;
				const element = document.createElement( 'a' );
				element.setAttribute( 'href', 'data:text/plain;charset=utf-8,' + encodeURIComponent( xmlHttp.responseText ) );
				element.setAttribute( 'download', filename );
				element.style.display = 'none';
				document.body.appendChild(element);
				element.click();
				document.body.removeChild(element);
			}
		}
		xmlHttp.open( 'POST', requestURL, true );
		xmlHttp.setRequestHeader( "Content-Type", "application/json" );
		const args = { captions: captionsTable() };
		for ( const key of [ 'title', 'author', 'date' ] ) {
			let value = document.getElementById( 'video-' + key );
			if ( value ) {
				value = value.textContent.trim();
				if ( value.endsWith( ',' ) ) value = value.substr( 0, value.length - 1 ).trim();
				if ( value ) args[ key ] = value;
			}
		}
		let url = document.getElementById( 'video-descriptor' );
		if ( url ) {
			url = url.getAttribute( 'href' );
			if ( url ) args.url = url;
		}
		xmlHttp.send( JSON.stringify( args ) );
	}

	/**
	 * Convert the current captions state into an array of paragraphs,
	 * that are described as an array of timed bits, being described as [time,text].
	 */
	function captionsTable()/*: [string,string][][]*/ {
		cleanEditor();
		const res = [ [ [ '', '' ] ] ];
		let currentPar = res[ 0 ];
		let currentBit = currentPar[ 0 ];
		const newPar = () => {
			if ( currentPar.length ) {
				currentPar = [];
				res.push( currentPar );
			}
		};
		const newBit = ( span ) => {
			if ( ! span.textContent ) return;
			let t;
			try {
				t = span.getAttribute( 'data-time-ms' );
			} catch ( e ) { // Text node
				currentBit[ 1 ] += span.textContent.replaceAll( '&', '&amp;' ).replaceAll( '<', '&lt;' );
			}
			if ( t ) { // Timed span
				currentBit = [ t, span.innerHTML ];
				currentPar.push( currentBit );
			} else { // HTML tag, but not a timed span
				const tag = [ '', 'i', 'b', 'u' ][ [ 'I', 'B', 'U' ].indexOf( span.tagName ) + 1 ];
				const start = currentPar.length;
				for ( const subspan of span.childNodes ) {
					newBit( subspan );
				}
				if ( tag && currentPar.length > start ) {
					currentPar[ start ][ 1 ] = '<' + tag + '>' + currentPar[ start ][ 1 ];
					currentBit[ 1 ] += '</' + tag + '>';
				}
			}
		};
		for ( const p of captions.childNodes ) {
			if ( p.tagName === 'P' ) {
				newPar();
				for ( const span of p.childNodes ) {
					newBit( span );
				}
			} else {
				if ( p.textContent.trim() ) newBit( p );
			}
		}
		if ( ! currentPar.length ) res.pop();
		if ( res[ 0 ][ 0 ][ 1 ].trim() ) {
			res[ 0 ][ 0 ][ 0 ] = ( res.length > 1 ) ? res[ 1 ][ 0 ][ 0 ].replace( /\d/g, '0' ) : '00:00:00.000';
		} else {
			res.splice( 0 , 1 );
		}
		return res;
	}
	// Remove empty spans, remove unnecessary nbsp's, remove unsupported HTML tags, put French-typography-related nbsp's
	function cleanEditor() {
		const nbsp = String.fromCharCode( 160 );
		const clean = ( el ) => {
			if ( el.nodeType === 1 ) {
				if ( ! el.textContent.trim() ) {
					if ( el.tagName !== 'BR' ) el.remove();
					return;
				}
				for ( const e of el.childNodes ) clean( e );
			} else if ( el.nodeType === 3 ) {
				let s = el.textContent;
				if ( s[ 0 ] === nbsp ) s = ' ' + s.substr( 1 );
				if ( s[ s.length - 1 ] === nbsp ) s = s.substr( 0, s.length - 1 ) + ' ';
				el.textContent = s.replace( /(?<=[«({\[]) | (?=[»)}\]:;!?])/g, nbsp );
			}
		}
		for ( const el of captions.childNodes ) clean( el );
	}

	// document.addEventListener('copy', function(e) {
	// 	console.log('copied');
	// 	e.clipboardData.setData('text/plain', 'Hello World!');
	// 	e.preventDefault();
	// });
	//TODO Smart copy-paste
</script>

</body>
</html>
